{"version":3,"sources":["components/projectileMotion/inputField.js","components/projectileMotion/inputMap.js","components/projectileMotion/projectileMotion.js","components/spaceDodger/spaceDodger.js","App.js","reportWebVitals.js","index.js"],"names":["InputField","props","className","htmlFor","id","label","type","placeholder","defaultValue","onChange","e","handleChange","target","inputMap","inputDragMap","ProjectileMotion","useEffect","buildGrid","projectileList","projectileCount","applyDrag","pathMap","Map","projectileRadius","gridSizeY","gridSizeX","ballColor","mass","airDensity","dragCoeff","angle","fireVelocity","renderInterval","xCoor","yCoor","canvas","document","getElementById","canvasContext","getContext","save","scale","font","clearRect","beginPath","strokeStyle","strokeRect","fillStyle","fillRect","closePath","generateYAxis","generateXAxis","drawPath","forEach","proj","generateCanvasPrjojectile","xMovement","yMovement","radius","xSpeed","ySpeed","timeToImpact","velocityAngle","velocity","restore","setLineDash","value","point","i","moveTo","x","y","lineTo","stroke","color","time","arc","Math","PI","fill","translate","fillText","toFixed","rotate","startInterval","setInterval","start","round","abs","secToGame","winnerOverlay","createElement","innerHTML","querySelector","appendChild","interval","setTimeout","clearInterval","remove","setRenderGame","renderWinnerOverlay","bottom","sqrt","xNegAccel","yNegAccel","xDragForce","yDragForce","asin","has","get","push","filter","projectiles","length","handleInputChange","replace","newVal","fluid","isNaN","parseFloat","tabIndex","map","obj","index","style","display","height","width","onClick","cos","sin","set","firstId","delete","shift","SpaceDodger","xMovement2","yMovement2","isMultiPlayer","score","starList","smallBoxDim","objectList","stop","newObInterval","projSpeed","difficulty","keySet","Set","floor","random","drawStars","generateCanvasRect","star","focus","newObstacles","scoreTracker","window","localStorage","getItem","setItem","scoreKeep","hiScore","innerText","obstacleMovement","p1Detection","p2Detection","collisionDetection","overlay","clientHeight","clientWidth","gameOver","restart","onclick","handleRestart","handleKeyDown","key","preventDefault","add","k","toLowerCase","updateCanvas","handleKeyUp","onresize","onKeyDown","onKeyUp","App","useState","renderGame","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"gSAoBeA,EAjBI,SAACC,GAChB,OACI,sBAAKC,UAAU,wBAAf,UACI,uBAAOA,UAAU,aAAaC,QAASF,EAAMG,GAA7C,SACKH,EAAMI,QAEX,uBACID,GAAIH,EAAMG,GACVE,KAAK,OACLC,YAAaN,EAAMM,YACnBC,aAAcP,EAAMO,aACpBC,SAAU,SAACC,GAAD,OAAOT,EAAMU,aAAaD,EAAEE,eCdzCC,EAAW,CACpB,CACIT,GAAI,gBACJI,aAAc,GACdH,MAAO,mBACPE,YAAa,eAEjB,CACIH,GAAI,QACJI,aAAc,GACdH,MAAO,yBACPE,YAAa,eAEjB,CACIH,GAAI,SACJI,aAAc,EACdH,MAAO,eACPE,YAAa,sBAEjB,CACIH,GAAI,SACJI,aAAc,EACdH,MAAO,eACPE,YAAa,uBAIRO,EAAe,CACxB,CACIV,GAAI,OACJI,aAAc,IACdH,MAAO,YACPE,YAAa,cAEjB,CACIH,GAAI,SACJI,aAAc,EACdH,MAAO,wBACPE,YAAa,gBAEjB,CACIH,GAAI,QACJI,aAAc,MACdH,MAAO,yBACPE,YAAa,uBAEjB,CACIH,GAAI,YACJI,aAAc,GACdH,MAAO,mBACPE,YAAa,2BCsVNQ,G,MAnYU,SAACd,GACtBe,qBAAU,WACNC,MACD,IAEH,IAAIC,EAAiB,GACjBC,EAAkB,EAClBC,GAAY,EACZC,EAAU,IAAIC,IACdC,EAAmB,EACjBC,EAAY,IACZC,EAAY,KACZC,EAAY,OAEdC,EAAO,IACPC,EAAa,MACbC,EAAY,GACZC,EAAQ,GACRC,EAAe,GACfC,EAAiB,KACjBC,EAAQ,EACRC,EAAQ,EAENjB,EAAY,WACd,IAAIkB,EAASC,SAASC,eAAe,wBACrC,GAAIF,EAAQ,CACR,IAAIG,EAAgBH,EAAOI,WAAW,MACtCD,EAAcE,OACdF,EAAcG,MAfV,KAgBJH,EAAcI,KAAO,eACrBJ,EAAcK,UAAU,EAAG,EAAGlB,EAAWD,GACzCc,EAAcM,YACdN,EAAcO,YAAc,QAC5BP,EAAcQ,WAAW,EAAG,EAAGrB,EAAWD,GAC1Cc,EAAcS,UAAY,QAC1BT,EAAcU,SAAS,EAAG,EAAGvB,KAAeD,KAC5Cc,EAAcW,YACdC,IACAC,IACAC,IACAlC,EAAemC,SAAQ,SAACC,GACpBC,EACID,EAAKE,UACLF,EAAKG,UACLH,EAAKI,OACLhC,EACA4B,EAAKK,OACLL,EAAKM,OACLN,EAAKO,aACLP,EAAKQ,cACLR,EAAKS,aAGbzB,EAAc0B,YAIhBZ,EAAW,WACb,IACId,EADSF,SAASC,eAAe,wBACVE,WAAW,MACtCD,EAAcM,YACdN,EAAc2B,YAAY,CAAC,EAAG,IAC9B3B,EAAcO,YAAc,MAC5BxB,EAAQgC,SAAQ,SAACa,GACbA,EAAMb,SAAQ,SAACc,EAAOC,GACR,IAANA,EACA9B,EAAc+B,OAAOF,EAAMG,EAAGH,EAAMI,GAEpCjC,EAAckC,OAAOL,EAAMG,EAAGH,EAAMI,SAIhDjC,EAAcmC,SACdnC,EAAc2B,YAAY,IAC1B3B,EAAcW,aAGZM,EAA4B,SAC9Be,EACAC,EACAb,EACAgB,EACAf,EACAC,EACAe,EACAb,EACAC,GAEA,IACIzB,EADSF,SAASC,eAAe,wBACVE,WAAW,MACtCD,EAAcM,YACdN,EAAcO,YAAc6B,EAC5BpC,EAAcsC,IAAIN,EAAGC,EAAGb,EAAQ,EAAG,EAAImB,KAAKC,IAC5CxC,EAAcyC,OACdzC,EAAcS,UAAY,UAC1BT,EAAcmC,SACdnC,EAAcW,YACdX,EAAcM,YACdN,EAAc0C,UAAUV,EAAGC,GAC3BjC,EAAc2C,SAAd,mBAAmCrB,EAAOsB,QAAQ,GAAlD,SAA6D,IAAK,IAClE5C,EAAc2C,SAAd,mBAAmCtB,EAAOuB,QAAQ,GAAlD,SAA6D,IAAK,IAClE5C,EAAc2C,SAAd,aAA6BX,EAAEY,QAAQ,GAAvC,OAAgD,IAAK,IACrD5C,EAAc2C,SAAd,cACWzD,EAAY+C,EAAIb,GAAQwB,QAAQ,GAD3C,OAEK,IACA,IAEL5C,EAAc2C,SAAd,aAA6BN,EAAKO,QAAQ,GAA1C,OAAmD,IAAK,IACxD5C,EAAc0C,WAAWV,GAAIC,GAC7BjC,EAAc0C,UAAUV,EAAGC,GAC3BjC,EAAc6C,OAAOrB,EAAsBe,KAAKC,GAAK,IAAhB,IACrCxC,EAAcO,YAAc,QAC5BP,EAAc+B,OAAO,GAAIX,GACzBpB,EAAckC,OAAO,GAAId,EAAoB,GAAXK,GAClCzB,EAAc+B,OAAO,EAAGX,GACxBpB,EAAckC,OAAO,EAAGd,EAAoB,GAAXK,GACjCzB,EAAc+B,OAAO,EAAGX,GACxBpB,EAAc0C,UAAU,GAAItB,EAAoB,GAAXK,GACrCzB,EAAc+B,OAAO,EAAG,GACxB/B,EAAckC,OAAO,EAAG,GACxBlC,EAAc+B,OAAO,EAAG,GACxB/B,EAAckC,QAAQ,EAAG,GACzBlC,EAAc0C,UAAU,EAAGtB,EAAoB,GAAXK,GACpCzB,EAAc0C,UAAU,EAAGtB,EAAoB,GAAXK,GACpCzB,EAAc+B,OAAO,EAAG,GACxB/B,EAAckC,OAAO,GAAI,GACzBlC,EAAc+B,OAAO,EAAG,GACxB/B,EAAckC,QAAQ,GAAI,GAC1BlC,EAAc0C,UAAU,GAAItB,EAAoB,GAAXK,GACrCzB,EAAc6C,SAASrB,EAAsBe,KAAKC,GAAK,IAAhB,KACvCxC,EAAc0C,WAAWV,GAAIC,GAC7BjC,EAAc0C,UAAUV,EAAGC,GAC3BjC,EAAc+B,OAAO,EAAGX,GACxBpB,EAAckC,OAAO,EAAGd,EAAS,IACjCpB,EAAc0C,UAAU,EAAGtB,EAAS,IACpCpB,EAAc+B,OAAO,EAAG,GACxB/B,EAAckC,OAAO,GAAI,GACzBlC,EAAc+B,OAAO,EAAG,GACxB/B,EAAckC,QAAQ,GAAI,GAC1BlC,EAAc0C,UAAU,GAAItB,EAAS,IACrCpB,EAAc0C,WAAWV,GAAIC,GAC7BjC,EAAcmC,SACdnC,EAAcS,UAAY2B,EAC1BpC,EAAcW,aAGZC,EAAgB,WAIlB,IAHA,IAEIZ,EADSF,SAASC,eAAe,wBACVE,WAAW,MAC7B6B,EAAI,EAAGA,GAHI5C,EAGgB4C,IAChC9B,EAAcM,YACdN,EAAcS,UAAY,QAC1BT,EAAc2C,SAAd,UAA8B,IAAJb,EAA1B,KAAsC,EAAG5C,EAAgB,IAAJ4C,GACrD9B,EAAcS,UAAYrB,EAC1BY,EAAcW,aAIhBE,EAAgB,WAIlB,IAHA,IAEIb,EADSF,SAASC,eAAe,wBACVE,WAAW,MAC7B6B,EAAI,EAAGA,GAHI3C,GAGgB2C,IAChC9B,EAAcM,YACdN,EAAcS,UAAY,QAC1BT,EAAc2C,SAAd,UAA8B,IAAJb,EAA1B,KAA0C,IAAJA,EAAS5C,GAC/Cc,EAAcS,UAAYrB,EAC1BY,EAAcW,aAsBhBmC,EAAgB,WAClBpD,EAAiBqD,aAAY,WACrBjD,SAASC,eAAe,wBACxBnB,EAAemC,SAAQ,SAACC,GACpB,GACIA,EAAKG,UAAYjC,EAAY8B,EAAKI,SACnB,IAAfJ,EAAKgC,MAELhC,EAAKG,UAAYjC,EAAY8B,EAAKI,OAEC,MAA/BmB,KAAKU,MAAMjC,EAAKE,YACN,IAAV1B,GACoB,KAApB+C,KAAKW,IAAI1D,IACTC,EAAe,IA/BX,WACxB,IAAI0D,EAAY,EACVC,EAAgBtD,SAASuD,cAAc,OAC7CD,EAAcE,UACV,mDACJF,EAAcxF,UAAY,iBAC1BkC,SAASyD,cAAc,SAASC,YAAYJ,GAC5C,IAAMK,EAAWV,aAAY,WACzBI,IACAC,EAAcE,UAAd,4CAA+DH,EAA/D,mBACD,KACHO,YAAW,WACPC,cAAcF,GACdL,GAAiBA,EAAcQ,SAC/BjG,EAAMkG,eAAc,KACrB,KAkBiBC,GAEJ9C,EAAK+C,QAAS,OAKd,GAHI/C,EAAKG,UAAYjC,EAAY8B,EAAKI,SAClCJ,EAAKgC,OAAQ,IAEG,IAAhBhC,EAAK+C,OAAkB,CACvB/C,EAAKM,OAASN,EAAKM,OAAS,KAC5B,IAAIG,EAAWc,KAAKyB,KAChB,SAAAhD,EAAKM,OAAU,GAAf,SAAmBN,EAAKK,OAAU,IAElC4C,EAAY,KACZC,EAAY,KAChB,GAAIpF,EAAW,CACX,IAAIqF,EAEA,GADA5E,EAEAD,EAFA,SAGA0B,EAAKK,OAAU,GACfkB,KAAKC,GAJL,SAKAxB,EAAKI,OAAU,GACfgD,EAEA,GADA7E,EAEAD,EAFA,SAGA0B,EAAKM,OAAU,GACfiB,KAAKC,GAJL,SAKAxB,EAAKI,OAAU,GACnB6C,EAAYE,EAAa9E,EAAO,IAChC6E,EAAYE,EAAa/E,EAAO,IAEpC2B,EAAKQ,cAAgBe,KAAK8B,KACtBrD,EAAKM,OAASG,GAEd3C,IACAkC,EAAKK,QAAU4C,EACXjD,EAAKM,OAAS,EACdN,EAAKM,QAAU4C,EAEflD,EAAKM,QAAU4C,GAGvBlD,EAAKS,SAAWA,EAChBT,EAAKE,UAAYF,EAAKE,UAAYF,EAAKK,OAAS,IAChDL,EAAKG,UAAYH,EAAKG,UAAYH,EAAKM,OAAS,IAChDN,EAAKO,aAAeP,EAAKO,aAAe,IACpCxC,EAAQuF,IAAItD,EAAKlD,KACjBiB,EAAQwF,IAAIvD,EAAKlD,IAAI0G,KAAK,CACtBxC,EAAGhB,EAAKE,UACRe,EAAGjB,EAAKG,YAKxBxC,OAGJgF,cAAcjE,GAKM,IAHTd,EAAe6F,QAC1B,SAACC,GAAD,OAAwC,IAAvBA,EAAYX,UAEpBY,QACThB,cAAcjE,KAEnB,KA4BDkF,EAAoB,SAACtG,GACvBA,EAAOsD,MAAQtD,EAAOsD,MAAMiD,QAAQ,YAAa,IAChC,CACb,SAAU,SAACC,GAAD,OAAalF,EAAQkF,GAC/B,SAAU,SAACA,GAAD,OAAanF,EAAQmF,GAC/BtF,MAAO,SAACsF,GAAD,OAAatF,EAAQsF,GAC5B,gBAAiB,SAACA,GAAD,OAAarF,EAAeqF,GAC7CzF,KAAM,SAACyF,GAAD,OAAazF,EAAOyF,GAC1B1D,OAAQ,SAAC0D,GAAD,OAAa7F,EAAmB6F,GACxCC,MAAO,SAACD,GAAD,OAAaxF,EAAawF,GACjCvF,UAAW,SAACuF,GAAD,OAAavF,EAAYuF,IAE7BxG,EAAOR,IAEdQ,EAAOsD,QAAUoD,MAAM1G,EAAOsD,OACxBqD,WAAW3G,EAAOsD,OAClB,OAad,OACI,sBAAKhE,UAAU,iBAAiBE,GAAG,iBAAiBoH,SAAS,IAA7D,UACI,0BAAStH,UAAU,eAAnB,UACI,sBAAKA,UAAU,kBAAf,UACKW,EAAS4G,KAAI,SAACC,EAAKC,GAChB,OACI,cAAC,EAAD,CAEIvH,GAAIsH,EAAItH,GACRG,YAAamH,EAAInH,YACjBC,aAAckH,EAAIlH,aAClBH,MAAOqH,EAAIrH,MACXM,aAAcuG,GALTS,MASjB,sBAAKzH,UAAU,wBAAwBE,GAAG,iBAA1C,UACI,uBAAOF,UAAU,aAAaC,QAAQ,OAAtC,wBAGA,uBACIC,GAAG,OACHE,KAAK,WACLG,SAhCA,WACpBW,GAAaA,EAETgB,SAASC,eAAe,eAAeuF,MAAMC,QAD7CzG,EACuD,OAEA,gBA+BnD,qBACIlB,UAAU,uBACVE,GAAG,cACHwH,MAAO,CAAEC,QAAS,QAHtB,SAKK/G,EAAa2G,KAAI,SAACC,EAAKC,GACpB,OACI,cAAC,EAAD,CAEIvH,GAAIsH,EAAItH,GACRG,YAAamH,EAAInH,YACjBC,aAAckH,EAAIlH,aAClBH,MAAOqH,EAAIrH,MACXM,aAAcuG,GALTS,WAWzB,qBAAKzH,UAAU,iBAAiBE,GAAG,4BAAnC,SACI,wBACIF,UAAU,SACVE,GAAG,uBACH0H,OAAQtG,KACRuG,MAAOtG,KACPuG,QA1GU,WAiBtB,GAhBA/B,cAAcjE,GACdd,EAAe4F,KAAK,CAChB1G,GAAIe,EACJ2C,cAAe,EACfwB,OAAO,EACPzB,aAAc,EACdL,UAAWvB,EACXwB,UAAWjC,EAAYU,EAAQX,EAC/B8E,QAAQ,EACR1C,OAAQkB,KAAKoD,IAAInG,GAAS+C,KAAKC,GAAK,MAAQ/C,EAC5C6B,QAASiB,KAAKqD,IAAIpG,GAAS+C,KAAKC,GAAK,MAAQ/C,EAC7CgC,SAAU,EACVL,OAAQnC,IAEZF,EAAQ8G,IAAIhH,EAAiB,IAC7BA,IAC8B,IAA1BD,EAAe+F,OAAc,CAC7B,IAAImB,EAAUlH,EAAe,GAAGd,GAChCiB,EAAQgH,OAAOD,GACflH,EAAeoH,QAEnBlD,cCqCOmD,G,MA/UK,WAChB,IAAI/E,EAAY,GACZC,EAAY,IACZ+E,EAAa,GACbC,EAAa,IACbC,EAAgB,KAChBC,EAAQ,EACRC,EAAW,GACTC,EAAc,GACdrH,EAAY,IACZC,EAAY,IAEdqH,EAAa,CAAC,CAAExE,EAAG7C,GAAa,CAAE6C,EAAG7C,IAErCsH,GAAO,EACPC,EAAgB,IAChBC,EAAY,GACZC,EAAa,KACbC,EAAS,IAAIC,IAMjB,GAJApI,qBAAU,WACNC,MACD,IAEqB,IAApB2H,EAAS3B,OACT,IAAK,IAAI7C,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAIE,EAAIO,KAAKwE,MAAMxE,KAAKyE,SAAW7H,GAC/B8C,EAAIM,KAAKwE,MAAMxE,KAAKyE,SAAW9H,GACnCoH,EAAS9B,KAAK,CAAExC,EAAGA,EAAGC,EAAGA,IAIjC,IAAMtD,EAAY,WACd,IACIqB,EADSF,SAASC,eAAe,iBACVE,WAAW,MACtCD,EAAcE,OACdF,EAAcG,MAzBN,KA0BRH,EAAcK,UAAU,EAAG,EAAGlB,EAAWD,GACzCc,EAAcM,YACdN,EAAcQ,WAAW,EAAG,EAAGrB,EAAWD,GAC1Cc,EAAcW,YACdsG,IACAC,EACIhG,EACAC,EACAoF,EACAA,EACA,SAEAH,GACAc,EACIhB,EACAC,EACAI,EACAA,EACA,UAGRC,EAAWzF,SAAQ,SAACqE,GACXA,EAAInD,IACLmD,EAAInD,EAAIM,KAAKwE,MAAMxE,KAAKyE,SAAW9H,IAEvCgI,EAAmB9B,EAAIpD,EAAGoD,EAAInD,EAAG,GAAI,EAAG,UAE5CjC,EAAc0B,WAGZwF,EAAqB,SAAClF,EAAGC,EAAGwD,EAAOD,EAAQpD,GAC7C,IACIpC,EADSF,SAASC,eAAe,iBACVE,WAAW,MACtCD,EAAcM,YACdN,EAAcS,UAAY2B,EAC1BpC,EAAcU,SAASsB,EAAGC,EAAGwD,EAAOD,GACpCxF,EAAcmC,SACdnC,EAAcW,aAGZsG,EAAY,WACd,IACIjH,EADSF,SAASC,eAAe,iBACVE,WAAW,MAEtCD,EAAcO,YAAc,QAE5B+F,EAASvF,SAAQ,SAACoG,GACdnH,EAAcM,YACdN,EAAcsC,IAAI6E,EAAKnF,EAAGmF,EAAKlF,EAAG,EAAG,EAAG,EAAIM,KAAKC,IACjDxC,EAAcmC,SACdnC,EAAcW,gBAIhBqC,EAAQ,SAARA,IACElD,SAASC,eAAe,kBACxBD,SAASC,eAAe,iBAAiB6D,SAE7C9D,SAASC,eAAe,kBAAkBqH,QAC1C,IAAIC,EAAetE,aAAY,WAC3ByD,EAAWhC,KAAK,CAAExC,EAAG7C,IACjBqH,EAAW,IAAMA,EAAW,GAAGxE,IAAM,IACrCwE,EAAWR,QAEfrH,MACD+H,GAECY,EAAevE,aAAY,WAW3B,GAVAsD,IAEIkB,OAAOC,aAAaC,QAAQ,aAC5BpB,EAAQkB,OAAOC,aAAaC,QAAQ,YAEpCF,OAAOC,aAAaE,QAAQ,WAAYrB,GAChCkB,OAAOC,aAAaC,QAAQ,aACpCF,OAAOC,aAAaE,QAAQ,WAAYrB,GAE/BvG,SAASC,eAAe,kBACzB,CACR,IAAI4H,EAAY7H,SAASC,eAAe,gBACpC6H,EAAU9H,SAASC,eAAe,YACtC4H,EAAUE,UAAV,iBAAgCxB,GAChCuB,EAAQC,UAAR,qBAAkCN,OAAOC,aAAaC,QAClD,gBAGT,KAgBCK,EAAmB/E,aAAY,WAK/B,GAJAyD,EAAWzF,SAAQ,SAACqE,GAChBA,EAAIpD,IAhBe,SAACoD,GACxB,IAAI2C,EACA7G,EAAYqF,IAAgBnB,EAAIpD,GAChCb,GAAaiE,EAAInD,GACjBd,EAAYoF,GAAenB,EAAInD,EAC/B+F,EACA9B,EAAaK,IAAgBnB,EAAIpD,GACjCmE,GAAcf,EAAInD,GAClBkE,EAAaI,GAAenB,EAAInD,GAChC8F,GAAgB3B,GAAiB4B,KACjCvB,GAAO,GAOPwB,CAAmB7C,MAEnBqB,IAAS3G,SAASC,eAAe,kBAKjC,GAJA4D,cAAcmE,GACdnE,cAAc0D,GACd1D,cAAc2D,GACd3D,cAAciD,GACV9G,SAASC,eAAe,kBAAmB,CAC3C,IAAImI,EAAUpI,SAASuD,cAAc,OACrC6E,EAAQpK,GAAK,iBACboK,EAAQ5C,MAAME,OACV1F,SAASyD,cAAc,UAAU4E,aAAe,KACpDD,EAAQ5C,MAAMG,MACV3F,SAASyD,cAAc,UAAU6E,YAAc,KACnD,IAAIC,EAAWvI,SAASuD,cAAc,MACtCgF,EAASR,UAAY,aACrBK,EAAQ1E,YAAY6E,GACpB,IAAIC,EAAUxI,SAASuD,cAAc,UACrCiF,EAAQT,UAAY,UACpBS,EAAQC,QAAUC,EAClBN,EAAQ1E,YAAY8E,GACpBxI,SACKC,eAAe,kBACfyD,YAAY0E,SAGrBvJ,MAELgI,GAEHC,EAAa7D,aAAY,WACrBY,cAAcmE,GACdnE,cAAc0D,GACd1D,cAAc2D,GACd3D,cAAciD,GACdF,GAAgC,GAChCC,GAAwB,GACnBF,GACDzD,MAEL,MAGDwF,EAAgB,WAClB1I,SAASC,eAAe,kBAAkB6D,SAC1C1C,EAAY,GACZC,EAAY,IACZ+E,EAAa,GACbC,EAAa,IACbO,EAAgB,IAChBC,EAAY,GACZN,EAAQ,EACRG,EAAa,CAAC,CAAExE,EAAG7C,GAAa,CAAE6C,EAAG7C,IACrCsH,GAAO,EACPzD,KA0DEyF,EAAgB,SAACrK,GAvDH,IAACsK,EAwDjBtK,EAAEuK,iBAxDeD,EAyDLtK,EAAEsK,IAxDd7B,EAAO+B,IAAIF,GAyDX7B,EAAO9F,SAAQ,SAAC8H,IAlDC,SAACH,GAClB,OAAQA,EAAII,eACR,IAAK,UACiB,IAAd3H,IACAA,GAtMM,GAwMV,MACJ,IAAK,YACGA,GAAajC,MACbiC,GA3MM,GA6MV,MACJ,IAAK,YACiB,IAAdD,IACAA,GAhNM,GAkNV,MACJ,IAAK,aACGA,GAAa/B,MACb+B,GArNM,GAuNV,MACJ,IAAK,IACGkF,GAAgC,IAAfD,IACjBA,GA1NM,GA4NV,MACJ,IAAK,IACGC,GAAiBD,GAAcjH,MAC/BiH,GA/NM,GAiOV,MACJ,IAAK,IACGC,GAAgC,IAAfF,IACjBA,GApOM,GAsOV,MACJ,IAAK,IACGE,GAAiBF,GAAc/G,MAC/B+G,GAzOM,IAqPd6C,CAAaF,OAIfG,EAAc,SAAC5K,GA3DI,IAACsK,EA4DtBtK,EAAEuK,iBA5DoBD,EA6DLtK,EAAEsK,IA5DnB7B,EAAOd,OAAO2C,IAyElB,OAVAnB,OAAO0B,SAAW,WACd,GAAInJ,SAASC,eAAe,kBAAmB,CAC3C,IAAImI,EAAUpI,SAASC,eAAe,kBACtCmI,EAAQ5C,MAAME,OACV1F,SAASyD,cAAc,UAAU4E,aAAe,KACpDD,EAAQ5C,MAAMG,MACV3F,SAASyD,cAAc,UAAU6E,YAAc,OAKvD,sBACIxK,UAAU,iBACVE,GAAG,iBACHoH,SAAS,IACTgE,UAAW,SAAC9K,GAAD,OAAOqK,EAAcrK,IAChC+K,QAAS,SAAC/K,GAAD,OAAO4K,EAAY5K,IALhC,UAOI,qBAAKN,GAAG,eAAR,sBACA,sBAAKA,GAAG,WAAR,uBACe,IACVyJ,OAAOC,aAAaC,QAAQ,YACvBF,OAAOC,aAAaC,QAAQ,YAC5B,KAEV,sBAAK7J,UAAU,mBAAf,UACI,wBACI8H,QAAS,WACLU,GAAgB,GAFxB,sBAOA,wBACIV,QAAS,WACLU,GAAgB,GAFxB,yBAQJ,sBAAKxI,UAAU,iBAAiBE,GAAG,iBAAnC,UACI,sBACIA,GAAG,gBACHwH,MAAO,CACHE,OAAQtG,QACRuG,MAAOtG,SAJf,UAOI,0BAASvB,UAAU,sBAAnB,UACI,8CACA,uDACA,oDAEJ,wBAAQ8H,QAAS1C,EAAjB,sBAEJ,wBACIpF,UAAU,SACVE,GAAG,gBACHwH,MAAO,CAAEE,OAAQ,MAAOC,MAAO,OAC/BD,OAAQtG,IACRuG,MAAOtG,eCxTZiK,MAdf,WACI,MAAoCC,oBAAS,GAA7C,mBAAOC,EAAP,KAAmBzF,EAAnB,KAEA,OACI,qBAAKjG,UAAU,MAAf,SACM0L,EAGE,cAAC,EAAD,IAFA,cAAC,EAAD,CAAkBzF,cAAeA,OCClC0F,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFpK,SAASC,eAAe,SAM1BwJ,M","file":"static/js/main.3496fe7a.chunk.js","sourcesContent":["import React from 'react';\nimport './inputField.scss';\n\nconst InputField = (props) => {\n    return (\n        <div className='input-field-container'>\n            <label className='grid-label' htmlFor={props.id}>\n                {props.label}\n            </label>\n            <input\n                id={props.id}\n                type='text'\n                placeholder={props.placeholder}\n                defaultValue={props.defaultValue}\n                onChange={(e) => props.handleChange(e.target)}\n            ></input>\n        </div>\n    );\n};\n\nexport default InputField;\n","export const inputMap = [\n    {\n        id: 'fire-velocity',\n        defaultValue: 60,\n        label: 'Fire Speed (m/s)',\n        placeholder: 'Enter Speed',\n    },\n    {\n        id: 'angle',\n        defaultValue: 45,\n        label: 'Firing Angle (degrees)',\n        placeholder: 'Enter Angle',\n    },\n    {\n        id: 'x-coor',\n        defaultValue: 0,\n        label: 'X Coordinate',\n        placeholder: 'Enter x-coordinate',\n    },\n    {\n        id: 'y-coor',\n        defaultValue: 0,\n        label: 'Y Coordinate',\n        placeholder: 'Enter y-coordinate',\n    },\n];\n\nexport const inputDragMap = [\n    {\n        id: 'mass',\n        defaultValue: 1000,\n        label: 'Mass (kg)',\n        placeholder: 'Enter Mass',\n    },\n    {\n        id: 'radius',\n        defaultValue: 5,\n        label: 'Projectile Radius (m)',\n        placeholder: 'Enter Radius',\n    },\n    {\n        id: 'fluid',\n        defaultValue: 1.225,\n        label: 'Fluid Density (kg/m^3)',\n        placeholder: 'Enter Fluid Density',\n    },\n    {\n        id: 'dragCoeff',\n        defaultValue: 0.5,\n        label: 'Drag Coefficient',\n        placeholder: 'Enter Drag Coefficient',\n    },\n];\n","import React, { useEffect } from 'react';\nimport InputField from './inputField';\nimport { inputDragMap, inputMap } from './inputMap';\nimport './projectileMotion.scss';\n\nconst ProjectileMotion = (props) => {\n    useEffect(() => {\n        buildGrid();\n    }, []);\n\n    let projectileList = [];\n    let projectileCount = 0;\n    let applyDrag = false;\n    let pathMap = new Map();\n    let projectileRadius = 5;\n    const gridSizeY = 700;\n    const gridSizeX = 1200;\n    const ballColor = 'blue';\n    const dpr = 3;\n    let mass = 1000;\n    let airDensity = 1.225;\n    let dragCoeff = 0.5;\n    let angle = 45;\n    let fireVelocity = 60;\n    let renderInterval = null;\n    let xCoor = 0;\n    let yCoor = 0;\n\n    const buildGrid = () => {\n        let canvas = document.getElementById('my-canvas-projectile');\n        if (canvas) {\n            let canvasContext = canvas.getContext('2d');\n            canvasContext.save();\n            canvasContext.scale(dpr, dpr);\n            canvasContext.font = '0.9rem Arial';\n            canvasContext.clearRect(0, 0, gridSizeX, gridSizeY);\n            canvasContext.beginPath();\n            canvasContext.strokeStyle = 'black';\n            canvasContext.strokeRect(0, 0, gridSizeX, gridSizeY);\n            canvasContext.fillStyle = 'white';\n            canvasContext.fillRect(1, 1, gridSizeX - 2, gridSizeY - 2);\n            canvasContext.closePath();\n            generateYAxis();\n            generateXAxis();\n            drawPath();\n            projectileList.forEach((proj) => {\n                generateCanvasPrjojectile(\n                    proj.xMovement,\n                    proj.yMovement,\n                    proj.radius,\n                    ballColor,\n                    proj.xSpeed,\n                    proj.ySpeed,\n                    proj.timeToImpact,\n                    proj.velocityAngle,\n                    proj.velocity,\n                );\n            });\n            canvasContext.restore();\n        }\n    };\n\n    const drawPath = () => {\n        let canvas = document.getElementById('my-canvas-projectile');\n        let canvasContext = canvas.getContext('2d');\n        canvasContext.beginPath();\n        canvasContext.setLineDash([3, 3]);\n        canvasContext.strokeStyle = 'red';\n        pathMap.forEach((value) => {\n            value.forEach((point, i) => {\n                if (i === 0) {\n                    canvasContext.moveTo(point.x, point.y);\n                } else {\n                    canvasContext.lineTo(point.x, point.y);\n                }\n            });\n        });\n        canvasContext.stroke();\n        canvasContext.setLineDash([]);\n        canvasContext.closePath();\n    };\n\n    const generateCanvasPrjojectile = (\n        x,\n        y,\n        radius,\n        color,\n        xSpeed,\n        ySpeed,\n        time,\n        velocityAngle,\n        velocity,\n    ) => {\n        let canvas = document.getElementById('my-canvas-projectile');\n        let canvasContext = canvas.getContext('2d');\n        canvasContext.beginPath();\n        canvasContext.strokeStyle = color;\n        canvasContext.arc(x, y, radius, 0, 2 * Math.PI);\n        canvasContext.fill();\n        canvasContext.fillStyle = '#000000';\n        canvasContext.stroke();\n        canvasContext.closePath();\n        canvasContext.beginPath();\n        canvasContext.translate(x, y);\n        canvasContext.fillText(`y-speed: ${ySpeed.toFixed(3)} m/s`, -10, -70);\n        canvasContext.fillText(`x-speed: ${xSpeed.toFixed(3)} m/s`, -10, -55);\n        canvasContext.fillText(`x: ${x.toFixed(3)} m`, -10, -40);\n        canvasContext.fillText(\n            `y: ${(gridSizeY - y - radius).toFixed(3)} m`,\n            -10,\n            -25,\n        );\n        canvasContext.fillText(`t: ${time.toFixed(3)} s`, -10, -10);\n        canvasContext.translate(-x, -y);\n        canvasContext.translate(x, y);\n        canvasContext.rotate(velocityAngle + 90 * (Math.PI / 180));\n        canvasContext.strokeStyle = 'green';\n        canvasContext.moveTo(0, -radius);\n        canvasContext.lineTo(0, -radius - velocity * 0.8);\n        canvasContext.moveTo(0, radius);\n        canvasContext.lineTo(0, radius + velocity * 0.5);\n        canvasContext.moveTo(0, radius);\n        canvasContext.translate(0, -radius - velocity * 0.8);\n        canvasContext.moveTo(0, 0);\n        canvasContext.lineTo(3, 5);\n        canvasContext.moveTo(0, 0);\n        canvasContext.lineTo(-3, 5);\n        canvasContext.translate(0, radius + velocity * 0.8);\n        canvasContext.translate(0, radius + velocity * 0.5);\n        canvasContext.moveTo(0, 0);\n        canvasContext.lineTo(3, -5);\n        canvasContext.moveTo(0, 0);\n        canvasContext.lineTo(-3, -5);\n        canvasContext.translate(0, -radius - velocity * 0.5);\n        canvasContext.rotate(-(velocityAngle + 90 * (Math.PI / 180)));\n        canvasContext.translate(-x, -y);\n        canvasContext.translate(x, y);\n        canvasContext.moveTo(0, radius);\n        canvasContext.lineTo(0, radius + 25);\n        canvasContext.translate(0, radius + 25);\n        canvasContext.moveTo(0, 0);\n        canvasContext.lineTo(3, -5);\n        canvasContext.moveTo(0, 0);\n        canvasContext.lineTo(-3, -5);\n        canvasContext.translate(0, -radius - 25);\n        canvasContext.translate(-x, -y);\n        canvasContext.stroke();\n        canvasContext.fillStyle = color;\n        canvasContext.closePath();\n    };\n\n    const generateYAxis = () => {\n        let intervalCount = gridSizeY / 100;\n        let canvas = document.getElementById('my-canvas-projectile');\n        let canvasContext = canvas.getContext('2d');\n        for (let i = 0; i <= intervalCount; i++) {\n            canvasContext.beginPath();\n            canvasContext.fillStyle = 'black';\n            canvasContext.fillText(`${i * 100}m`, 0, gridSizeY - i * 100);\n            canvasContext.fillStyle = ballColor;\n            canvasContext.closePath();\n        }\n    };\n\n    const generateXAxis = () => {\n        let intervalCount = gridSizeX / 100;\n        let canvas = document.getElementById('my-canvas-projectile');\n        let canvasContext = canvas.getContext('2d');\n        for (let i = 1; i <= intervalCount; i++) {\n            canvasContext.beginPath();\n            canvasContext.fillStyle = 'black';\n            canvasContext.fillText(`${i * 100}m`, i * 100, gridSizeY);\n            canvasContext.fillStyle = ballColor;\n            canvasContext.closePath();\n        }\n    };\n\n    const renderWinnerOverlay = () => {\n        let secToGame = 5;\n        const winnerOverlay = document.createElement('div');\n        winnerOverlay.innerHTML =\n            '<h1>Winner! Starting mini game in 5 seconds</h1>';\n        winnerOverlay.className = 'winner-overlay';\n        document.querySelector('#root').appendChild(winnerOverlay);\n        const interval = setInterval(() => {\n            secToGame--;\n            winnerOverlay.innerHTML = `<h1>Winner! Starting mini game in ${secToGame} seconds</h1>`;\n        }, 1000);\n        setTimeout(() => {\n            clearInterval(interval);\n            winnerOverlay && winnerOverlay.remove();\n            props.setRenderGame(true);\n        }, 5000);\n    };\n\n    const startInterval = () => {\n        renderInterval = setInterval(() => {\n            if (document.getElementById('my-canvas-projectile')) {\n                projectileList.forEach((proj) => {\n                    if (\n                        proj.yMovement > gridSizeY - proj.radius &&\n                        proj.start === false\n                    ) {\n                        proj.yMovement = gridSizeY - proj.radius;\n                        if (\n                            Math.round(proj.xMovement) === 777 &&\n                            angle !== 0 &&\n                            Math.abs(angle) !== 90 &&\n                            fireVelocity > 10\n                        ) {\n                            renderWinnerOverlay();\n                        }\n                        proj.bottom = true;\n                    } else {\n                        if (proj.yMovement < gridSizeY - proj.radius) {\n                            proj.start = false;\n                        }\n                        if (proj.bottom === false) {\n                            proj.ySpeed = proj.ySpeed + 9.8 / 100;\n                            let velocity = Math.sqrt(\n                                proj.ySpeed ** 2 + proj.xSpeed ** 2,\n                            );\n                            let xNegAccel = null;\n                            let yNegAccel = null;\n                            if (applyDrag) {\n                                let xDragForce =\n                                    dragCoeff *\n                                    0.5 *\n                                    airDensity *\n                                    proj.xSpeed ** 2 *\n                                    Math.PI *\n                                    proj.radius ** 2;\n                                let yDragForce =\n                                    dragCoeff *\n                                    0.5 *\n                                    airDensity *\n                                    proj.ySpeed ** 2 *\n                                    Math.PI *\n                                    proj.radius ** 2;\n                                xNegAccel = xDragForce / mass / 100;\n                                yNegAccel = yDragForce / mass / 100;\n                            }\n                            proj.velocityAngle = Math.asin(\n                                proj.ySpeed / velocity,\n                            );\n                            if (applyDrag) {\n                                proj.xSpeed -= xNegAccel;\n                                if (proj.ySpeed < 0) {\n                                    proj.ySpeed += yNegAccel;\n                                } else {\n                                    proj.ySpeed -= yNegAccel;\n                                }\n                            }\n                            proj.velocity = velocity;\n                            proj.xMovement = proj.xMovement + proj.xSpeed / 100;\n                            proj.yMovement = proj.yMovement + proj.ySpeed / 100;\n                            proj.timeToImpact = proj.timeToImpact + 0.01;\n                            if (pathMap.has(proj.id)) {\n                                pathMap.get(proj.id).push({\n                                    x: proj.xMovement,\n                                    y: proj.yMovement,\n                                });\n                            }\n                        }\n                    }\n                    buildGrid();\n                });\n            } else {\n                clearInterval(renderInterval);\n            }\n            let tempList = projectileList.filter(\n                (projectiles) => projectiles.bottom === false,\n            );\n            if (tempList.length === 0) {\n                clearInterval(renderInterval);\n            }\n        }, 10);\n    };\n\n    const handleCanvasClick = () => {\n        clearInterval(renderInterval);\n        projectileList.push({\n            id: projectileCount,\n            velocityAngle: 0,\n            start: true,\n            timeToImpact: 0,\n            xMovement: xCoor,\n            yMovement: gridSizeY - yCoor - projectileRadius,\n            bottom: false,\n            xSpeed: Math.cos(angle * (Math.PI / 180)) * fireVelocity,\n            ySpeed: -Math.sin(angle * (Math.PI / 180)) * fireVelocity,\n            velocity: 0,\n            radius: projectileRadius,\n        });\n        pathMap.set(projectileCount, []);\n        projectileCount++;\n        if (projectileList.length === 4) {\n            let firstId = projectileList[0].id;\n            pathMap.delete(firstId);\n            projectileList.shift();\n        }\n        startInterval();\n    };\n\n    const handleInputChange = (target) => {\n        target.value = target.value.replace(/[^0-9\\.]/g, '');\n        const valueMap = {\n            'y-coor': (newVal) => (yCoor = newVal),\n            'x-coor': (newVal) => (xCoor = newVal),\n            angle: (newVal) => (angle = newVal),\n            'fire-velocity': (newVal) => (fireVelocity = newVal),\n            mass: (newVal) => (mass = newVal),\n            radius: (newVal) => (projectileRadius = newVal),\n            fluid: (newVal) => (airDensity = newVal),\n            dragCoeff: (newVal) => (dragCoeff = newVal),\n        };\n        const id = target.id;\n        valueMap[id](\n            target.value && !isNaN(target.value)\n                ? parseFloat(target.value)\n                : null,\n        );\n    };\n\n    const toggleDragInput = () => {\n        applyDrag = !applyDrag;\n        if (applyDrag) {\n            document.getElementById('drag-inputs').style.display = 'flex';\n        } else {\n            document.getElementById('drag-inputs').style.display = 'none';\n        }\n    };\n\n    return (\n        <div className='draw-container' id='draw-container' tabIndex='0'>\n            <section className='input-parent'>\n                <div className='input-container'>\n                    {inputMap.map((obj, index) => {\n                        return (\n                            <InputField\n                                key={index}\n                                id={obj.id}\n                                placeholder={obj.placeholder}\n                                defaultValue={obj.defaultValue}\n                                label={obj.label}\n                                handleChange={handleInputChange}\n                            />\n                        );\n                    })}\n                    <div className='input-field-container' id='drag-container'>\n                        <label className='grid-label' htmlFor='drag'>\n                            Apply Drag\n                        </label>\n                        <input\n                            id='drag'\n                            type='checkbox'\n                            onChange={toggleDragInput}\n                        ></input>\n                    </div>\n                </div>\n                <div\n                    className='input-container drag'\n                    id='drag-inputs'\n                    style={{ display: 'none' }}\n                >\n                    {inputDragMap.map((obj, index) => {\n                        return (\n                            <InputField\n                                key={index}\n                                id={obj.id}\n                                placeholder={obj.placeholder}\n                                defaultValue={obj.defaultValue}\n                                label={obj.label}\n                                handleChange={handleInputChange}\n                            />\n                        );\n                    })}\n                </div>\n            </section>\n            <div className='move-container' id='projectile-move-container'>\n                <canvas\n                    className='canvas'\n                    id='my-canvas-projectile'\n                    height={gridSizeY * dpr}\n                    width={gridSizeX * dpr}\n                    onClick={handleCanvasClick}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport default ProjectileMotion;\n","import React, { useEffect } from 'react';\nimport './spaceDodger.scss';\n\nconst SpaceDodger = () => {\n    let xMovement = 20;\n    let yMovement = 200;\n    let xMovement2 = 20;\n    let yMovement2 = 220;\n    let isMultiPlayer = null;\n    let score = 0;\n    let starList = [];\n    const smallBoxDim = 10;\n    const gridSizeY = 400;\n    const gridSizeX = 800;\n    const dpr = 2;\n    let objectList = [{ x: gridSizeX }, { x: gridSizeX }];\n    const movementSpeed = 4;\n    let stop = false;\n    let newObInterval = 2000;\n    let projSpeed = 10;\n    let difficulty = null;\n    let keySet = new Set();\n\n    useEffect(() => {\n        buildGrid();\n    }, []);\n\n    if (starList.length === 0) {\n        for (let i = 0; i < 30; i++) {\n            let x = Math.floor(Math.random() * gridSizeX);\n            let y = Math.floor(Math.random() * gridSizeY);\n            starList.push({ x: x, y: y });\n        }\n    }\n\n    const buildGrid = () => {\n        let canvas = document.getElementById('my-canvas-obj');\n        let canvasContext = canvas.getContext('2d');\n        canvasContext.save();\n        canvasContext.scale(dpr, dpr);\n        canvasContext.clearRect(0, 0, gridSizeX, gridSizeY);\n        canvasContext.beginPath();\n        canvasContext.strokeRect(0, 0, gridSizeX, gridSizeY);\n        canvasContext.closePath();\n        drawStars();\n        generateCanvasRect(\n            xMovement,\n            yMovement,\n            smallBoxDim,\n            smallBoxDim,\n            'green',\n        );\n        if (isMultiPlayer) {\n            generateCanvasRect(\n                xMovement2,\n                yMovement2,\n                smallBoxDim,\n                smallBoxDim,\n                'yellow',\n            );\n        }\n        objectList.forEach((obj) => {\n            if (!obj.y) {\n                obj.y = Math.floor(Math.random() * gridSizeY);\n            }\n            generateCanvasRect(obj.x, obj.y, 10, 2, 'red');\n        });\n        canvasContext.restore();\n    };\n\n    const generateCanvasRect = (x, y, width, height, color) => {\n        let canvas = document.getElementById('my-canvas-obj');\n        let canvasContext = canvas.getContext('2d');\n        canvasContext.beginPath();\n        canvasContext.fillStyle = color;\n        canvasContext.fillRect(x, y, width, height);\n        canvasContext.stroke();\n        canvasContext.closePath();\n    };\n\n    const drawStars = () => {\n        let canvas = document.getElementById('my-canvas-obj');\n        let canvasContext = canvas.getContext('2d');\n\n        canvasContext.strokeStyle = 'white';\n\n        starList.forEach((star) => {\n            canvasContext.beginPath();\n            canvasContext.arc(star.x, star.y, 1, 0, 2 * Math.PI);\n            canvasContext.stroke();\n            canvasContext.closePath();\n        });\n    };\n\n    const start = () => {\n        if (document.getElementById('start-overlay')) {\n            document.getElementById('start-overlay').remove();\n        }\n        document.getElementById('draw-container').focus();\n        let newObstacles = setInterval(() => {\n            objectList.push({ x: gridSizeX });\n            if (objectList[0] && objectList[0].x <= -20) {\n                objectList.shift();\n            }\n            buildGrid();\n        }, newObInterval);\n\n        let scoreTracker = setInterval(() => {\n            score++;\n            if (\n                window.localStorage.getItem('hi-score') &&\n                score > window.localStorage.getItem('hi-score')\n            ) {\n                window.localStorage.setItem('hi-score', score);\n            } else if (!window.localStorage.getItem('hi-score')) {\n                window.localStorage.setItem('hi-score', score);\n            }\n            let isDraw = document.getElementById('draw-container');\n            if (isDraw) {\n                let scoreKeep = document.getElementById('score-keeper');\n                let hiScore = document.getElementById('hi-score');\n                scoreKeep.innerText = `Score: ${score}`;\n                hiScore.innerText = `Highscore: ${window.localStorage.getItem(\n                    'hi-score',\n                )}`;\n            }\n        }, 200);\n\n        const collisionDetection = (obj) => {\n            let p1Detection =\n                xMovement + smallBoxDim === obj.x &&\n                yMovement <= obj.y &&\n                yMovement + smallBoxDim >= obj.y;\n            let p2Detection =\n                xMovement2 + smallBoxDim === obj.x &&\n                yMovement2 <= obj.y &&\n                yMovement2 + smallBoxDim >= obj.y;\n            if (p1Detection || (isMultiPlayer && p2Detection)) {\n                stop = true;\n            }\n        };\n\n        let obstacleMovement = setInterval(() => {\n            objectList.forEach((obj) => {\n                obj.x--;\n                collisionDetection(obj);\n            });\n            if (stop || !document.getElementById('my-canvas-obj')) {\n                clearInterval(obstacleMovement);\n                clearInterval(newObstacles);\n                clearInterval(scoreTracker);\n                clearInterval(difficulty);\n                if (document.getElementById('move-container')) {\n                    let overlay = document.createElement('div');\n                    overlay.id = 'canvas-overlay';\n                    overlay.style.height =\n                        document.querySelector('canvas').clientHeight + 'px';\n                    overlay.style.width =\n                        document.querySelector('canvas').clientWidth + 'px';\n                    let gameOver = document.createElement('h3');\n                    gameOver.innerText = 'GAME OVER!';\n                    overlay.appendChild(gameOver);\n                    let restart = document.createElement('button');\n                    restart.innerText = 'RESTART';\n                    restart.onclick = handleRestart;\n                    overlay.appendChild(restart);\n                    document\n                        .getElementById('move-container')\n                        .appendChild(overlay);\n                }\n            } else {\n                buildGrid();\n            }\n        }, projSpeed);\n\n        difficulty = setInterval(() => {\n            clearInterval(obstacleMovement);\n            clearInterval(newObstacles);\n            clearInterval(scoreTracker);\n            clearInterval(difficulty);\n            newObInterval = newObInterval * 0.5;\n            projSpeed = projSpeed * 0.9;\n            if (!stop) {\n                start();\n            }\n        }, 10000);\n    };\n\n    const handleRestart = () => {\n        document.getElementById('canvas-overlay').remove();\n        xMovement = 20;\n        yMovement = 200;\n        xMovement2 = 20;\n        yMovement2 = 220;\n        newObInterval = 2000;\n        projSpeed = 10;\n        score = 0;\n        objectList = [{ x: gridSizeX }, { x: gridSizeX }];\n        stop = false;\n        start();\n    };\n\n    const addToKeySet = (key) => {\n        keySet.add(key);\n    };\n\n    const removeFromKeySet = (key) => {\n        keySet.delete(key);\n    };\n\n    const updateCanvas = (key) => {\n        switch (key.toLowerCase()) {\n            case 'arrowup':\n                if (yMovement !== 0) {\n                    yMovement = yMovement - movementSpeed;\n                }\n                break;\n            case 'arrowdown':\n                if (yMovement <= gridSizeY - smallBoxDim) {\n                    yMovement = yMovement + movementSpeed;\n                }\n                break;\n            case 'arrowleft':\n                if (xMovement !== 0) {\n                    xMovement = xMovement - movementSpeed;\n                }\n                break;\n            case 'arrowright':\n                if (xMovement <= gridSizeX - smallBoxDim) {\n                    xMovement = xMovement + movementSpeed;\n                }\n                break;\n            case 'w':\n                if (isMultiPlayer && yMovement2 !== 0) {\n                    yMovement2 = yMovement2 - movementSpeed;\n                }\n                break;\n            case 's':\n                if (isMultiPlayer && yMovement2 <= gridSizeY - smallBoxDim) {\n                    yMovement2 = yMovement2 + movementSpeed;\n                }\n                break;\n            case 'a':\n                if (isMultiPlayer && xMovement2 !== 0) {\n                    xMovement2 = xMovement2 - movementSpeed;\n                }\n                break;\n            case 'd':\n                if (isMultiPlayer && xMovement2 <= gridSizeX - smallBoxDim) {\n                    xMovement2 = xMovement2 + movementSpeed;\n                }\n                break;\n            default:\n                break;\n        }\n    };\n\n    const handleKeyDown = (e) => {\n        e.preventDefault();\n        addToKeySet(e.key);\n        keySet.forEach((k) => {\n            updateCanvas(k);\n        });\n    };\n\n    const handleKeyUp = (e) => {\n        e.preventDefault();\n        removeFromKeySet(e.key);\n    };\n\n    window.onresize = () => {\n        if (document.getElementById('canvas-overlay')) {\n            let overlay = document.getElementById('canvas-overlay');\n            overlay.style.height =\n                document.querySelector('canvas').clientHeight + 'px';\n            overlay.style.width =\n                document.querySelector('canvas').clientWidth + 'px';\n        }\n    };\n\n    return (\n        <div\n            className='draw-container'\n            id='draw-container'\n            tabIndex='0'\n            onKeyDown={(e) => handleKeyDown(e)}\n            onKeyUp={(e) => handleKeyUp(e)}\n        >\n            <div id='score-keeper'>Score: 0</div>\n            <div id='hi-score'>\n                Highscore:{' '}\n                {window.localStorage.getItem('hi-score')\n                    ? window.localStorage.getItem('hi-score')\n                    : 0}\n            </div>\n            <div className='button-container'>\n                <button\n                    onClick={() => {\n                        isMultiPlayer = false;\n                    }}\n                >\n                    1 Player\n                </button>\n                <button\n                    onClick={() => {\n                        isMultiPlayer = true;\n                    }}\n                >\n                    2 Player\n                </button>\n            </div>\n            <div className='move-container' id='move-container'>\n                <div\n                    id='start-overlay'\n                    style={{\n                        height: gridSizeY + 'px',\n                        width: gridSizeX + 'px',\n                    }}\n                >\n                    <section className='instruction-section'>\n                        <h3>Instructions</h3>\n                        <div>Player 1: Arrow Keys</div>\n                        <div>Player 2: WASD</div>\n                    </section>\n                    <button onClick={start}>Start</button>\n                </div>\n                <canvas\n                    className='canvas'\n                    id='my-canvas-obj'\n                    style={{ height: '40%', width: '60%' }}\n                    height={gridSizeY * dpr}\n                    width={gridSizeX * dpr}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport default SpaceDodger;\n","import { useState } from 'react';\nimport { render } from 'sass';\nimport ProjectileMotion from './components/projectileMotion/projectileMotion';\nimport SpaceDodger from './components/spaceDodger/spaceDodger';\n\nfunction App() {\n    const [renderGame, setRenderGame] = useState(false);\n\n    return (\n        <div className='App'>\n            {!renderGame ? (\n                <ProjectileMotion setRenderGame={setRenderGame} />\n            ) : (\n                <SpaceDodger />\n            )}\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}